import { emitEnumExports, emitSchemas, createTypegenContext } from "./emitSchemas";
import { emitOperations } from "./emitOperations";
import { toSafeIdentifier } from "../../utils/naming";

export function emitTypesForSpec(args: {
  specId: string;
  sourcePath: string;
  document: any;
  operationTypePrefix: string; // e.g. "Billing_"
}): string {
  const { specId, sourcePath, document, operationTypePrefix } = args;

  const header = `/* eslint-disable */
/**
 * Generated by swagger-typegen
 * Spec ID: ${specId}
 * Source: ${sourcePath}
 * DO NOT EDIT MANUALLY
 */
`;

  const schemasObj = document?.components?.schemas ?? {};
  const schemaNames = Object.keys(schemasObj).map((raw) =>
    toSafeIdentifier(raw),
  );

  // Map of top-level enum schema name -> signature key
  const schemaEnumKeyByName = new Map<string, string>();
  for (const rawName of Object.keys(schemasObj)) {
    const ident = toSafeIdentifier(rawName);
    const s = schemasObj[rawName];
    if (Array.isArray(s?.enum) && s.enum.length > 0) {
      schemaEnumKeyByName.set(
        ident,
        JSON.stringify({ values: s.enum, nullable: !!s.nullable }),
      );
    }
  }

  const ctx = createTypegenContext({
    reservedNames: schemaNames,
    schemaEnumKeyByName,
  });

  // Generate schemas + ops first (collect enums during traversal)
  const schemas = emitSchemas(document, ctx);
  const ops = emitOperations(document, ctx, operationTypePrefix);

  // Now emit enums once, above references
  const enums = emitEnumExports(ctx);

  return [
    header,
    `// --------------------`,
    `// Enums`,
    `// --------------------`,
    enums || `// (no enums found)`,
    ``,
    `// --------------------`,
    `// Schemas`,
    `// --------------------`,
    schemas || `// (no components.schemas found)`,
    ``,
    `// --------------------`,
    `// Operations`,
    `// --------------------`,
    ops || `// (no operations found after filtering)`,
    ``,
  ].join("\n");
}

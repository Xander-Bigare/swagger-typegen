import { Config, ExpandedSpecInput } from "../config/types";
import { canonicalizeSchema } from "../openapi/canonicalizeSchema";
import { diffSchemas } from "../openapi/diffSchemas";
import { filterRoutes } from "../openapi/filterRoutes";
import { pruneSchemas } from "../openapi/pruneSchemas";
import { createTypegenContext, emitEnumExports, emitSchemas } from "../generate/typescript/emitSchemas";
import { emitOperations } from "../generate/typescript/emitOperations";
import { toSafeIdentifier } from "../utils/naming";

function ensureComponents(doc: any) {
  doc.components = doc.components ?? {};
  doc.components.schemas = doc.components.schemas ?? {};
}

export async function mergeSpecsAndEmit(
  cfg: Config,
  expanded: ExpandedSpecInput[],
): Promise<string> {
  // Filter + prune each spec first
  const prepared = expanded.map((s) => {
    const filtered = filterRoutes(s.document, s.routes);
    const pruned = cfg.features.pruneUnusedSchemas
      ? pruneSchemas(filtered)
      : filtered;
    return { ...s, document: pruned };
  });

  // Build a merged doc skeleton (schemas merged by name)
  const mergedDoc: any = {
    openapi: "3.0.0",
    info: { title: "Merged API", version: "0.0.0" },
    paths: {},
    components: { schemas: {} },
  };
  ensureComponents(mergedDoc);

  // Merge schemas by NAME (no renaming)
  for (const spec of prepared) {
    const schemas = spec.document?.components?.schemas ?? {};
    for (const [name, schema] of Object.entries<any>(schemas)) {
      const existing = mergedDoc.components.schemas[name];
      if (!existing) {
        mergedDoc.components.schemas[name] = schema;
        continue;
      }

      const a = canonicalizeSchema(existing);
      const b = canonicalizeSchema(schema);

      const aStr = JSON.stringify(a);
      const bStr = JSON.stringify(b);

      if (aStr === bStr) continue;

      const d = diffSchemas(a, b) ?? "unknown structural difference";
      throw new Error(
        [
          `Schema conflict while merging.`,
          `Schema name: ${name}`,
          `Incoming spec: ${spec.specId}`,
          `Difference: ${d}`,
          `NOTE: swagger-typegen does not rename schemas. Fix the spec(s) or disable mergeOutput.`,
        ].join("\n"),
      );
    }
  }

  const header = `/* eslint-disable */
/**
 * Generated by swagger-typegen (merged mode)
 * DO NOT EDIT MANUALLY
 */
`;

  const mergedSchemasObj = mergedDoc?.components?.schemas ?? {};
  const reservedSchemaNames = Object.keys(mergedSchemasObj).map((raw) =>
    toSafeIdentifier(raw),
  );

  // top-level enum signatures in merged doc
  const schemaEnumKeyByName = new Map<string, string>();
  for (const rawName of Object.keys(mergedSchemasObj)) {
    const ident = toSafeIdentifier(rawName);
    const s = mergedSchemasObj[rawName];
    if (Array.isArray(s?.enum) && s.enum.length > 0) {
      schemaEnumKeyByName.set(
        ident,
        JSON.stringify({ values: s.enum, nullable: !!s.nullable }),
      );
    }
  }

  const ctx = createTypegenContext({
    reservedNames: reservedSchemaNames,
    schemaEnumKeyByName,
  });

  // Generate schemas (collect enums)
  const schemasText = emitSchemas(mergedDoc, ctx);

  // Generate operations per spec (collect enums from inline param/body/resp enums too)
  const opsParts: string[] = [];
  for (const spec of prepared) {
    const prefix = `${toSafeIdentifier(spec.specId)}_`;
    const ops = emitOperations(spec.document, ctx, prefix);
    opsParts.push(
      `// ====================`,
      `// Operations: ${spec.specId}`,
      `// Source: ${spec.sourcePath}`,
      `// ====================`,
      ops || `// (no operations found after filtering)`,
      ``,
    );
  }

  // Emit enums once at top
  const enumsText = emitEnumExports(ctx);

  return [
    header,
    `// --------------------`,
    `// Enums`,
    `// --------------------`,
    enumsText || `// (no enums found)`,
    ``,
    `// --------------------`,
    `// Schemas`,
    `// --------------------`,
    schemasText || `// (no components.schemas found)`,
    ``,
    ...opsParts,
  ].join("\n");
}
